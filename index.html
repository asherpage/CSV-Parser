<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CSV Sanitize & Export</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        background: linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 50%, #16213e 100%);
        color: #e0e0e0;
        min-height: 100vh;
        padding: 24px;
        line-height: 1.6;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        animation: fadeIn 0.6s ease-out;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      h2 {
        font-size: 2.5rem;
        font-weight: 700;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin-bottom: 12px;
        letter-spacing: -0.5px;
      }

      .subtitle {
        color: #a0a0b0;
        font-size: 1.1rem;
        margin-bottom: 32px;
      }

      .upload-section {
        background: rgba(255, 255, 255, 0.05);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 16px;
        padding: 32px;
        margin-bottom: 24px;
        transition: all 0.3s ease;
      }

      .upload-section:hover {
        background: rgba(255, 255, 255, 0.08);
        border-color: rgba(102, 126, 234, 0.5);
        transform: translateY(-2px);
        box-shadow: 0 8px 32px rgba(102, 126, 234, 0.2);
      }

      .file-input-wrapper {
        position: relative;
        display: inline-block;
        cursor: pointer;
        width: 100%;
      }

      input[type="file"] {
        position: absolute;
        opacity: 0;
        width: 100%;
        height: 100%;
        cursor: pointer;
      }

      .file-input-label {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        padding: 20px 32px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-radius: 12px;
        font-size: 1.1rem;
        font-weight: 600;
        transition: all 0.3s ease;
        box-shadow: 0 4px 16px rgba(102, 126, 234, 0.4);
      }

      .file-input-label:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 24px rgba(102, 126, 234, 0.6);
      }

      .file-input-label::before {
        content: "üìÅ";
        font-size: 1.5rem;
      }

      #info {
        margin-top: 16px;
        padding: 16px;
        background: rgba(102, 126, 234, 0.1);
        border-left: 4px solid #667eea;
        border-radius: 8px;
        font-size: 0.95rem;
        color: #b8c7ff;
        min-height: 50px;
        display: flex;
        align-items: center;
        animation: slideIn 0.4s ease-out;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateX(-20px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      #controls {
        display: none;
        gap: 12px;
        margin-bottom: 24px;
        flex-wrap: wrap;
      }

      #controls.visible {
        display: flex;
        animation: slideIn 0.5s ease-out;
      }

      button {
        padding: 14px 28px;
        border: none;
        border-radius: 10px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
      }

      button::before {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0;
        height: 0;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.3);
        transform: translate(-50%, -50%);
        transition: width 0.6s, height 0.6s;
      }

      button:hover::before {
        width: 300px;
        height: 300px;
      }

      #downloadCsv {
        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        color: white;
        box-shadow: 0 4px 16px rgba(17, 153, 142, 0.4);
      }

      #downloadCsv:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 24px rgba(17, 153, 142, 0.6);
      }

      #downloadJson {
        background: linear-gradient(135deg, #fc4a1a 0%, #f7b733 100%);
        color: white;
        box-shadow: 0 4px 16px rgba(252, 74, 26, 0.4);
      }

      #downloadJson:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 24px rgba(252, 74, 26, 0.6);
      }

      button span {
        position: relative;
        z-index: 1;
      }

      #tableWrap {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 16px;
        padding: 24px;
        overflow-x: auto;
        animation: fadeIn 0.6s ease-out 0.2s both;
      }

      table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        font-size: 0.9rem;
      }

      th {
        background: linear-gradient(135deg, rgba(102, 126, 234, 0.2) 0%, rgba(118, 75, 162, 0.2) 100%);
        color: #b8c7ff;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        padding: 16px 12px;
        text-align: left;
        border-bottom: 2px solid rgba(102, 126, 234, 0.5);
        position: sticky;
        top: 0;
        z-index: 10;
      }

      th:first-child {
        border-top-left-radius: 12px;
      }

      th:last-child {
        border-top-right-radius: 12px;
      }

      td {
        padding: 14px 12px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        color: #d0d0d8;
        transition: all 0.2s ease;
      }

      tr {
        transition: all 0.2s ease;
      }

      tr:hover td {
        background: rgba(102, 126, 234, 0.1);
        color: #ffffff;
      }

      tr:last-child td:first-child {
        border-bottom-left-radius: 12px;
      }

      tr:last-child td:last-child {
        border-bottom-right-radius: 12px;
      }

      .truncate-notice {
        text-align: center;
        font-style: italic;
        color: #a0a0b0;
        background: rgba(102, 126, 234, 0.05);
        padding: 16px;
      }

      ::-webkit-scrollbar {
        width: 10px;
        height: 10px;
      }

      ::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
      }

      ::-webkit-scrollbar-thumb {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 10px;
      }

      ::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
      }

      .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: #667eea;
        animation: spin 1s ease-in-out infinite;
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }

      @media (max-width: 768px) {
        body {
          padding: 16px;
        }

        h2 {
          font-size: 2rem;
        }

        .upload-section {
          padding: 20px;
        }

        button {
          width: 100%;
        }

        table {
          font-size: 0.8rem;
        }

        th, td {
          padding: 10px 8px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h2>CSV Sanitize & Export</h2>
      <p class="subtitle">Clean, normalize, and export your CSV data with ease</p>
      
      <div class="upload-section">
        <div class="file-input-wrapper">
          <input id="file" type="file" accept=".csv,text/csv" />
          <div class="file-input-label">
            Choose CSV File
          </div>
        </div>
        <div id="info"></div>
      </div>

      <div id="controls">
        <button id="downloadCsv"><span>üíæ Download CSV (UTF-8)</span></button>
        <button id="downloadJson"><span>üìÑ Download JSON</span></button>
      </div>

      <div id="tableWrap"></div>
    </div>

    <script>
      const NORMALIZE_OPTIONS = {
        transliterateAccents: false,
        dashReplacement: "-",
        ellipsisReplacement: "...",
        arrowReplacement: "->",
        checkmarkReplacement: "yes",
        degreeReplacement: "deg",
        replaceLineBreaksWith: "<br>",
        trimAndCollapseWhitespace: false,
      };

      function looksLikeEscapedOrRawHtml(s) {
        if (!s || typeof s !== "string") return false;
        // Check for backslash-escaped HTML (e.g., \<div)
        if (/\\<\s*\w+/i.test(s)) return true;
        if (/\&lt;\s*\w+/i.test(s)) return true;
        if (/<\s*\w+/i.test(s)) return true;
        return false;
      }

      function unescapeAngleBrackets(str) {
        return String(str)
          .replace(/\\</g, "<")
          .replace(/\\>/g, ">")
          .replace(/&lt;/g, "<")
          .replace(/&gt;/g, ">");
      }

      function normalizeTextNodeString(s, opts = {}) {
        if (s == null) return s;
        opts = Object.assign({}, NORMALIZE_OPTIONS, opts);
        let out = String(s);
        out = out
          .replace(/\u00A0/g, " ")
          .replace(/\u200B/g, "")
          .replace(/\uFEFF/g, "");
        out = out
          .replace(/[\u2018\u2019\u201A\u201B\u2032\u2035]/g, "'")
          .replace(/[\u201C\u201D\u201E\u201F\u2033\u2036]/g, '"');
        const dash = opts.dashReplacement || "-";
        out = out.replace(
          /[\u2012\u2013\u2014\u2015\u2212\u2010\u2011\u2043\uFE58\uFE63\uFF0D]/g,
          dash
        );
        out = out.replace(
          /[\u2026\u22EF\u22EE]/g,
          opts.ellipsisReplacement || "..."
        );
        out = out.replace(/\u2022/g, "-").replace(/\u2043/g, "-");
        out = out
          .replace(/\u2122/g, " (TM)")
          .replace(/\u00AE/g, " (R)")
          .replace(/\u00A9/g, " (C)");
        if (opts.degreeReplacement !== false)
          out = out.replace(/\u00B0/g, " " + opts.degreeReplacement);
        if (opts.checkmarkReplacement !== false)
          out = out.replace(/[‚úì‚úî]/g, opts.checkmarkReplacement);
        if (opts.arrowReplacement !== false) {
          out = out
            .replace(/[‚Üí‚Ü¶‚á¢‚û°‚ûú‚ûî‚ûô‚ûõ]/g, opts.arrowReplacement)
            .replace(/[‚Üê‚Ü§‚¨Ö]/g, "<-");
        }
        out = out
          .replace(/[√ó]/g, "x")
          .replace(/[√∑]/g, "/")
          .replace(/[¬±]/g, "+/-");
        if (opts.transliterateAccents) {
          out = out
            .replace(/√ü/g, "ss")
            .replace(/≈ì/g, "oe")
            .replace(/≈í/g, "OE")
            .replace(/√∏/g, "o")
            .replace(/√ò/g, "O");
          out = out.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
        }
        if (opts.trimAndCollapseWhitespace)
          out = out
            .replace(/\t+/g, " ")
            .replace(/[ ]{2,}/g, " ")
            .trim();

        return out;
      }

      // Convert newlines to <br> tags BEFORE parsing as HTML
      function convertNewlinesToBr(htmlString) {
        // First normalize all line endings
        let s = htmlString.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
        
        // Convert double newlines (paragraph breaks) to <br><br>
        s = s.replace(/\n\s*\n/g, "<br><br>");
        
        // Convert remaining single newlines to <br>
        s = s.replace(/\n/g, "<br>");
        
        return s;
      }

      function normalizeHtmlPreservingAttributes(htmlString, opts = {}) {
        let s = String(htmlString);
        
        // Unescape any escaped angle brackets first
        s = unescapeAngleBrackets(s);
        
        // Convert existing escaped <br> tags
        s = s
          .replace(/&lt;br\s*\/?&gt;/gi, "<br>")
          .replace(/&amp;lt;br\s*\/?&amp;gt;/gi, "<br>");

        // CRITICAL: Convert newlines to <br> BEFORE DOMParser processes it
        // DOMParser normalizes whitespace, so we must do this first
        s = convertNewlinesToBr(s);

        const parser = new DOMParser();
        const doc = parser.parseFromString(s, "text/html");

        // Walk text nodes and normalize unicode characters only
        const walker = doc.createTreeWalker(
          doc.body,
          NodeFilter.SHOW_TEXT,
          null,
          false
        );
        let node;
        while ((node = walker.nextNode())) {
          const text = node.nodeValue;
          if (text == null) continue;
          // Only normalize unicode, don't touch newlines (already converted to <br>)
          node.nodeValue = normalizeTextNodeString(text, { 
            ...opts, 
            replaceLineBreaksWith: false 
          });
        }

        return doc.body.innerHTML;
      }

      function normalizeCell(s, opts = {}) {
        if (s == null) return s;
        opts = Object.assign({}, NORMALIZE_OPTIONS, opts);

        if (opts.preserveHtml) {
          return normalizeHtmlPreservingAttributes(String(s), opts);
        }

        let out = String(s);
        
        // First, normalize all line endings to \n
        out = out.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
        
        out = out
          .replace(/\u00A0/g, " ")
          .replace(/\u200B/g, "")
          .replace(/\uFEFF/g, "");
        out = out
          .replace(/[\u2018\u2019\u201A\u201B\u2032\u2035]/g, "'")
          .replace(/[\u201C\u201D\u201E\u201F\u2033\u2036]/g, '"');
        const dash = opts.dashReplacement || "-";
        out = out.replace(
          /[\u2012\u2013\u2014\u2015\u2212\u2010\u2011\u2043\uFE58\uFE63\uFF0D]/g,
          dash
        );
        out = out.replace(
          /[\u2026\u22EF\u22EE]/g,
          opts.ellipsisReplacement || "..."
        );
        out = out.replace(/\u2022/g, "-").replace(/\u2043/g, "-");
        out = out
          .replace(/\u2122/g, " (TM)")
          .replace(/\u00AE/g, " (R)")
          .replace(/\u00A9/g, " (C)");
        if (opts.degreeReplacement !== false)
          out = out.replace(/\u00B0/g, " " + opts.degreeReplacement);
        if (opts.checkmarkReplacement !== false)
          out = out.replace(/[‚úì‚úî]/g, opts.checkmarkReplacement);
        if (opts.arrowReplacement !== false) {
          out = out
            .replace(/[‚Üí‚Ü¶‚á¢‚û°‚ûú‚ûî‚ûô‚ûõ]/g, opts.arrowReplacement)
            .replace(/[‚Üê‚Ü§‚¨Ö]/g, "<-");
        }
        out = out
          .replace(/[√ó]/g, "x")
          .replace(/[√∑]/g, "/")
          .replace(/[¬±]/g, "+/-");

        // Preserve existing <br> tags
        out = out
          .replace(/<br\s*\/?>/gi, "___BR___")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/___BR___/g, "<br>");

        // Handle line breaks - double newlines become paragraph breaks, single become line breaks
        if (opts.replaceLineBreaksWith !== false) {
          // First handle paragraph breaks (2+ newlines with possible whitespace)
          out = out.replace(/\n\s*\n/g, "<br><br>");
          // Then handle remaining single newlines
          out = out.replace(/\n/g, opts.replaceLineBreaksWith);
        }

        // Also detect sentences run together (period followed immediately by capital letter)
        // But be more careful - only when there's a closing tag right before
        out = out.replace(/(<\/strong><\/span>)([A-Z])/g, "$1<br><br>$2");
        out = out.replace(/(<\/span>)([A-Z])/g, "$1<br><br>$2");

        if (opts.transliterateAccents) {
          out = out
            .replace(/√ü/g, "ss")
            .replace(/≈ì/g, "oe")
            .replace(/≈í/g, "OE")
            .replace(/√∏/g, "o")
            .replace(/√ò/g, "O");
          out = out.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
        }
        if (opts.trimAndCollapseWhitespace)
          out = out
            .replace(/\t+/g, " ")
            .replace(/[ ]{2,}/g, " ")
            .trim();

        return out;
      }

      function parseCSV(text, delim = ",") {
        text = text.replace(/\r\n/g, "\n");
        const rows = [];
        let cur = "";
        let row = [];
        let inQuotes = false;
        for (let i = 0; i < text.length; i++) {
          const ch = text[i];
          const nxt = text[i + 1];
          if (inQuotes) {
            if (ch === '"') {
              if (nxt === '"') {
                cur += '"';
                i++;
              } else inQuotes = false;
            } else cur += ch;
            continue;
          }
          if (ch === '"') {
            inQuotes = true;
            continue;
          }
          if (ch === delim) {
            row.push(cur);
            cur = "";
            continue;
          }
          if (ch === "\r") continue;
          if (ch === "\n") {
            row.push(cur);
            rows.push(row);
            row = [];
            cur = "";
            continue;
          }
          cur += ch;
        }
        if (cur !== "" || inQuotes || row.length > 0) {
          row.push(cur);
          rows.push(row);
        }
        return rows;
      }

      function rowsToCsv(rows) {
        return rows
          .map((row) =>
            row
              .map((cell) => {
                if (cell == null) cell = "";
                const s = String(cell);
                const escaped = s.replace(/"/g, '""');
                if (
                  escaped.includes(",") ||
                  escaped.includes("\n") ||
                  escaped.includes('"')
                )
                  return `"${escaped}"`;
                return escaped;
              })
              .join(",")
          )
          .join("\r\n");
      }

      document.getElementById("file").addEventListener("change", async (ev) => {
        const f = ev.target.files[0];
        if (!f) return;
        
        const infoDiv = document.getElementById("info");
        infoDiv.innerHTML = '<span class="loading"></span> Loading ' + f.name + ' (' + f.size.toLocaleString() + ' bytes)...';
        
        try {
          const buffer = await f.arrayBuffer();
          let text;
          try {
            const dec = new TextDecoder("utf-8", { fatal: true });
            text = dec.decode(buffer);
            infoDiv.textContent = "‚úì Decoded as UTF-8 ‚Äî " + f.name;
          } catch (e) {
            const dec2 = new TextDecoder("windows-1252");
            text = dec2.decode(buffer);
            infoDiv.textContent = "‚úì Decoded as windows-1252 (fallback) ‚Äî " + f.name;
          }
          if (text.charCodeAt(0) === 0xfeff) text = text.slice(1);
          const firstLines = text
            .split(/\r\n|\n/)
            .slice(0, 5)
            .join("\n");
          const commaCount = (firstLines.match(/,/g) || []).length;
          const semiCount = (firstLines.match(/;/g) || []).length;
          const delimiter = semiCount > commaCount ? ";" : ",";
          const rows = parseCSV(text, delimiter);
          const normalized = rows.map((row, rIndex) => {
            if (rIndex === 0) return row;
            return row.map((cell, cIndex) => {
              const header = rows[0][cIndex]?.trim().toLowerCase() || "";

              // Format Photo column
              if (
                header === "photo" &&
                cell &&
                !/\.jpg$/i.test(String(cell).trim())
              ) {
                cell = String(cell).trim() + ".jpg";
              }

              // Format DegreeAndYear column (Strip all apostrophes and prepend one)
              if (header === "degreeandyear" && cell) {
                let val = String(cell).trim();
                val = val.replace(/['\u2018\u2019]/g, ""); // Remove all types of single quotes
                cell = "'" + val; // Add one back to the start
              }

              if (looksLikeEscapedOrRawHtml(cell)) {
                const unescaped = unescapeAngleBrackets(cell);
                return normalizeCell(unescaped, {
                  transliterateAccents: false,
                  preserveHtml: true,
                });
              } else {
                return normalizeCell(cell, {
                  transliterateAccents: false,
                  preserveHtml: false,
                });
              }
            });
          });

          renderTable(normalized);
          setupDownloads(normalized, f.name);
          document.getElementById("controls").classList.add("visible");
        } catch (err) {
          infoDiv.textContent = "‚ùå Error reading file: " + err;
          console.error(err);
        }
      });

      function renderTable(rows) {
        const wrap = document.getElementById("tableWrap");
        wrap.innerHTML = "";
        if (!rows.length) {
          wrap.textContent = "No rows parsed.";
          return;
        }
        const table = document.createElement("table");
        const thead = document.createElement("thead");
        const header = document.createElement("tr");
        rows[0].forEach((h) => {
          const th = document.createElement("th");
          th.textContent = h;
          header.appendChild(th);
        });
        thead.appendChild(header);
        table.appendChild(thead);
        
        const tbody = document.createElement("tbody");
        for (let r = 1; r < rows.length; r++) {
          const tr = document.createElement("tr");
          rows[r].forEach((cell) => {
            const td = document.createElement("td");
            // Always use innerHTML to render <br> tags
            td.innerHTML = cell;
            tr.appendChild(td);
          });
          tbody.appendChild(tr);
          if (r >= 200) {
            const tr2 = document.createElement("tr");
            const td = document.createElement("td");
            td.colSpan = rows[0].length;
            td.className = "truncate-notice";
            td.textContent =
              "...table truncated for display (first 200 rows shown)";
            tr2.appendChild(td);
            tbody.appendChild(tr2);
            break;
          }
        }
        table.appendChild(tbody);
        wrap.appendChild(table);
      }

      function setupDownloads(rows, originalName) {
        const csvBtn = document.getElementById("downloadCsv");
        const jsonBtn = document.getElementById("downloadJson");
        csvBtn.onclick = () => {
          const csv = rowsToCsv(rows);
          const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download =
            (originalName || "sanitized").replace(/\.csv$/i, "") +
            "-sanitized.csv";
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
        };
        jsonBtn.onclick = () => {
          const headers = rows[0] || [];
          const data = rows.slice(1).map((r) => {
            const obj = {};
            for (let i = 0; i < headers.length; i++)
              obj[headers[i] || `col${i + 1}`] = r[i] ?? "";
            return obj;
          });
          const blob = new Blob([JSON.stringify(data, null, 2)], {
            type: "application/json;charset=utf-8",
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download =
            (originalName || "data").replace(/\.csv$/i, "") + "-sanitized.json";
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
        };
      }
    </script>
  </body>
</html>
